/* Generated By:JavaCC: Do not edit this line. TyRuBaParser.java */
package tyRuBa.parser;

import java.io.*;
import java.util.*;
import tyRuBa.engine.*;
import tyRuBa.modes.*;
import tyRuBa.util.ElementSource;
import java.net.URL;
import java.net.MalformedURLException;

public class TyRuBaParser implements TyRuBaParserConstants {

        private PrintStream outputStream;
        private URL baseURL = null;
        private boolean interactive;

        public TyRuBaParser(InputStream is,PrintStream os) {
                this(is,os,null);
        }

        public TyRuBaParser(InputStream is,PrintStream os, URL base) {
                this(is);
                outputStream = os;
                baseURL = base;
                interactive = is == System.in;
        }

        /** Parse from a URL, add any facts and rules it defines into the
		rulebase, "rules". Any code which is generated during parsing
		(by #generate directives) is written to the PrintStream
		"os".
      
		The file may contain queries, (usually for debugging purposes).
		The results of these queries will be reported to the standard
		error device. */

        public static void parse(QueryEngine rules,URL url,PrintStream os)
        throws ParseException, IOException, TypeModeError {
                InputStream is = url.openStream();
                try {
                        TyRuBaParser parser = new TyRuBaParser(is,os,url);
                        parser.CompilationUnit(rules);
                }
                finally {
                        is.close();
                }
        }

        /** Parse from a file, add any facts and rules it defines into the
		rulebase. Any code which is generated during parsing
		(by #generate directives) is written to the PrintStream
		"os".
      
		The file may contain queries, (usually for debugging purposes).
		The results of these queries will be reported to the standard
		error device. */

        public static void parse(QueryEngine rules,String fileName,PrintStream os)
        throws ParseException, IOException, TypeModeError {
                parse(rules,new File(fileName).toURL(),os);
        }

        /** Parsing from an InputStream (interactive mode) */
        public static void parse(QueryEngine rules,InputStream is,PrintStream os)
        throws ParseException, TypeModeError {
                TyRuBaParser parser = new TyRuBaParser(is,os);
                parser.CompilationUnit(rules);
        }

    public static RBExpression parseExpression(InputStream is,PrintStream os,QueryEngine rules)
        throws ParseException, TypeModeError {
                TyRuBaParser parser = new TyRuBaParser(is,os);
                return parser.ExpressionAndEOF(rules);
        }

        /** Compute the string from the image of a string literal, quotes already 
		removed before calling this method. */
        static String internalStringLiteral(String src) {
                StringBuffer trg = new StringBuffer(src.length());
                for (int i = 0; i < src.length(); i++) {
                        if (src.charAt(i) == '\\') {
                                i++;
                                //This does not yet implement any of the special character code
                                //such as \t \n etc.
                                // \\ works however, also \" works. 
                                trg.append(src.charAt(i));
                        }
                        else {
                                trg.append(src.charAt(i));
                        }
                }
                return trg.toString();
        }

        /** Compute the string from the image of a string literal. */
        static String stringLiteral(String src) {
                return internalStringLiteral(stripQuotes(src));
        }

        /** Strip of first and last chars, supposedly they are some kind of quotes */
        static String stripQuotes(String src) {
                return src.substring(1, src.length() - 1);
        }

        /** Extract the class name from JAVA_CLASS token */
        static String javaClassName(String classToken) {
                if (classToken.endsWith("[]"))
                        return "[L" + classToken.substring(1, classToken.length() - 2) + ";";
                else
                        return classToken.substring(1);
        }

        /** Replace all occurrences of ?? by ? */
        private static String undoubleQuestionMarks(String src) {
                StringBuffer trg = new StringBuffer(src.length());
                for (int i = 0; i < src.length(); i++) {
                        if (src.charAt(i) == '?' && i + 1 < src.length()
                                && src.charAt(i + 1) == '?') {
                                //System.err.println("Removed char at " + i + "in \"" + src + "\"");
                                trg.append(src.charAt(i++)); //append one and skip the other	
                        }
                        else
                                trg.append(src.charAt(i));
                }
                return trg.toString();
        }

        /** Auxiliary function for makeQuotedCode: snip of the first part of the
		string upto the next Variable. */
        private static RBTerm makeQuotedCodeName(String s, int startName) {
                int startVar = s.indexOf('?', startName);
                while (startVar < s.length() && s.charAt(startVar + 1) == '?') {
                        // The ? is escaped
                        startVar = s.indexOf('?',startVar+2);
                }
                if (startVar == -1) {
                        if (s.length() - startName > 1)
                                return FrontEnd.makeName(
                                        undoubleQuestionMarks(s.substring(startName, s.length() - 1)));
                        else
                                return FrontEnd.theEmptyList;
                }
                else {
                        // There's a name first, then there's variable
                        if (startVar == startName)
                                //Oops there is no name after all, the name is empty
                                return makeQuotedCodeVar(s,startVar);
                        else {
                                //Ah now there is a name!
                                RBTerm car = FrontEnd.makeName(
                                        undoubleQuestionMarks(s.substring(startName, startVar)));
                                return new RBPair(car, makeQuotedCodeVar(s, startVar));
                        }
                }
        }

        /** Auxiliary function for makeQuotedCode: snip of the first part of the
		string which matches a variable. */
        private static RBTerm makeQuotedCodeVar(String s, int startVar) {
                int startName = startVar + 1;
                while (startName < s.length() - 1
                        && Character.isJavaIdentifierPart(s.charAt(startName)))
                        startName++;
                RBVariable car = FrontEnd.makeVar(s.substring(startVar, startName));
                return new RBPair(car, makeQuotedCodeName(s, startName));
        }

        /** Analyze the text of a {} block and turn it into a RBQuotedCode object. */
        static RBTerm makeQuotedCode(String s) {
                return new RBQuoted(makeQuotedCodeName(s, 1));
        }

/*****************************************
 * AN IMPROVISED (PSEUDO)PROLOG GRAMMAR
 *****************************************/

/*
 * Program structuring syntax follows.
 */
  final public void CompilationUnit(QueryEngine rules) throws ParseException, TypeModeError {
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INCLUDE:
      case LIBRARY:
      case TYPEDEF:
      case WHEN:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      if (jj_2_1(2)) {
        PredInfoRules(rules);
                if (interactive)
                        System.err.println("** predicate info added to db **");
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TYPEDEF:
          UserDefinedTypeDeclaration(rules);
                if (interactive)
                        System.err.println("** I have defined your type! **");
          break;
        case IDENTIFIER:
          Rule(rules);
                if (interactive)
                        System.err.println("** assertion added to rulebase **");
          break;
        case WHEN:
          Query(rules);
          break;
        case INCLUDE:
          IncludeDirective(rules);
          break;
        case LIBRARY:
          LibraryDirective(rules);
          break;
        default:
          jj_la1[1] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    jj_consume_token(0);
  }

//void GenerateDirective(QueryEngine rules) throws TypeModeError :
//{ RBTerm className; }
//{
// "#generate" className=CompoundTerm(rules) 
//   { CodeGenerator cg = new CodeGenerator(rules,className);
//     cg.generate(outputStream);
//   }
//}
  final public void LibraryDirective(QueryEngine rules) throws ParseException, TypeModeError {
        Token t;
        URL url;
        String fileName;
    jj_consume_token(LIBRARY);
    t = jj_consume_token(STRING_LITERAL);
                try {
                        fileName = stringLiteral(t.image);
                        System.err.println("LOADING LIBRARY " + fileName);
                        rules.loadLibrary(fileName);
                        System.err.println("LOADING LIBRARY " + fileName + " Done");
                }
                catch (MalformedURLException e) {
                        System.err.println("Warning: MalformedURL in #library");
                        System.err.println(e.getMessage());
                }
                catch (IOException e) {
                        System.err.println("Warning: IOException in #library");
                        System.err.println(e.getMessage());
                }
  }

  final public void IncludeDirective(QueryEngine rules) throws ParseException, TypeModeError {
        Token t;
        URL url;
        String fileName;
    jj_consume_token(INCLUDE);
    t = jj_consume_token(STRING_LITERAL);
                try {
                        fileName = stringLiteral(t.image);
                        if (baseURL != null) {
                        url = new URL(baseURL, fileName);
                        }
                        else
                                url = new URL(fileName);
                        System.err.println("INCLUDING " + url.toString());
                        parse(rules, url, outputStream);
                        System.err.println("INCLUDING " + url.toString() + " Done");
                }
                catch (MalformedURLException e) {
                        System.err.println("Warning: MalformedURL in #include");
                        System.err.println(e.getMessage());
                }
                catch (IOException e) {
                        System.err.println("Warning: IOException in #include");
                        System.err.println(e.getMessage());
                }
  }

  final public RBFact Fact(QueryEngine rules) throws ParseException, TypeModeError {
        RBPredicateExpression pred;
    pred = SimplePredicate(rules);
      {if (true) return new RBFact(pred);}
    throw new Error("Missing return statement in function");
  }

  final public void Rule(QueryEngine rules) throws ParseException, TypeModeError {
        RBPredicateExpression pred;
        RBExpression exp = null;
    pred = SimplePredicate(rules);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHEN:
      jj_consume_token(WHEN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NOT:
      case EXISTS:
      case FINDALL:
      case COUNTALL:
      case UNIQUE:
      case TEST:
      case LPAREN:
      case IDENTIFIER:
        exp = Expression(rules);
        break;
      case BOUND:
        exp = ModeSwitchExpression(rules);
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
    jj_consume_token(DOT);
                        if (exp == null)
                                rules.insert(pred);
                        else
                                rules.insert(new RBRule(pred, exp));
  }

  final public RBPredicateExpression SimplePredicate(QueryEngine rules) throws ParseException, TypeModeError {
        Token t;
        RBPredicateExpression e;
        ArrayList terms;
    t = jj_consume_token(IDENTIFIER);
    jj_consume_token(LPAREN);
                  terms = new ArrayList();
    TermList(terms, rules);
                  e = new RBPredicateExpression(t.image, terms);
    jj_consume_token(RPAREN);
          {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public void predNameList(ArrayList names) throws ParseException {
        Token t;
    t = jj_consume_token(IDENTIFIER);
                           names.add(t.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      predNameList(names);
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
  }

  final public void PredInfoRules(QueryEngine rules) throws ParseException, TypeModeError {
        ArrayList names = new ArrayList();
        TupleType types;
        PredInfo p;
        TVarFactory tfact;
        ArrayList predModes = new ArrayList();
        boolean isPersistent = false;
    predNameList(names);
    jj_consume_token(TYPE);
                types = Factory.makeTupleType();
                tfact = new TVarFactory();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACKET:
    case LANGLE:
    case STRICT:
    case IDENTIFIER:
    case VARIABLE:
      TypeList(types, tfact, rules);
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PERSISTENT:
      jj_consume_token(PERSISTENT);
                         isPersistent = true;
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MODES:
      jj_consume_token(MODES);
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_2;
        }
        ModeRule(predModes, types.size(), names);
      }
      jj_consume_token(MODEEND);
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
                        for (int i = 0; i < names.size(); i++) {
                                p = Factory.makePredInfo(rules,(String)names.get(i), types, predModes, isPersistent);
                                rules.insertPredInfo(p);
                        }
  }

  final public void TypeList(TupleType types, TVarFactory tfact, QueryEngine rules) throws ParseException, TypeModeError {
        Type t;
    t = Type(tfact, rules);
                  types.add(t);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      TypeList(types, tfact, rules);
      break;
    default:
      jj_la1[9] = jj_gen;
      ;
    }
  }

  final public Type Type(TVarFactory tfact, QueryEngine rules) throws ParseException, TypeModeError {
        Type t;
    if (jj_2_2(3)) {
      t = CompositeType(tfact, rules);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRICT:
      case IDENTIFIER:
        t = AtomicType(rules);
        break;
      case VARIABLE:
        t = TypeVariable(tfact);
        break;
      case LANGLE:
        t = TupleType(tfact, rules);
        break;
      case LBRACKET:
        t = ListType(tfact, rules);
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
          {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Type AtomicType(QueryEngine rules) throws ParseException, TypeModeError {
        Token t;
        Type type;
        boolean strict = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRICT:
      jj_consume_token(STRICT);
               strict = true;
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
    t = jj_consume_token(IDENTIFIER);
                if (strict)
                        type = Factory.makeStrictAtomicType(rules.findType(t.image));
                else
                        type = Factory.makeAtomicType(rules.findType(t.image));
                {if (true) return type;}
    throw new Error("Missing return statement in function");
  }

  final public Type CompositeType(TVarFactory tfact, QueryEngine rules) throws ParseException, TypeModeError {
        Token t;
        TupleType args;
        Type type;
        boolean strict = false;
        int arity = -1;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRICT:
      jj_consume_token(STRICT);
               strict = true;
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
    t = jj_consume_token(IDENTIFIER);
    //	(
           args = TupleType(tfact, rules);
                                       arity = ((TupleType)args).size();
                if (strict)
                        type = rules.findTypeConst(t.image, arity).applyStrict(args, false);
            else
                type = rules.findTypeConst(t.image, arity).apply(args, false);
                {if (true) return type;}
    throw new Error("Missing return statement in function");
  }

  final public Type ListType(TVarFactory tfact, QueryEngine rules) throws ParseException, TypeModeError {
        Type t;
    jj_consume_token(LBRACKET);
    t = Type(tfact, rules);
    jj_consume_token(RBRACKET);
          {if (true) return Factory.makeListType(t);}
    throw new Error("Missing return statement in function");
  }

  final public TupleType TupleType(TVarFactory tfact, QueryEngine rules) throws ParseException, TypeModeError {
        TupleType types = Factory.makeTupleType();
    jj_consume_token(LANGLE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACKET:
    case LANGLE:
    case STRICT:
    case IDENTIFIER:
    case VARIABLE:
      TypeList(types, tfact, rules);
      break;
    default:
      jj_la1[13] = jj_gen;
      ;
    }
    jj_consume_token(RANGLE);
          {if (true) return types;}
    throw new Error("Missing return statement in function");
  }

  final public TVar TypeVariable(TVarFactory tfact) throws ParseException {
        Token t;
    t = jj_consume_token(VARIABLE);
          {if (true) return tfact.makeTVar(t.image.substring(1));}
    throw new Error("Missing return statement in function");
  }

  final public void ModeRule(ArrayList predModes, int numArgs, ArrayList names) throws ParseException, TypeModeError {
        BindingList bList = Factory.makeBindingList();
        Mode mode;
        boolean toBeCheck = true;
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOUND:
    case IDENTIFIER:
      bList = ModeElem(bList);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[14] = jj_gen;
          break label_3;
        }
        jj_consume_token(COMMA);
        bList = ModeElem(bList);
      }
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
                if (bList.size() != numArgs) {
                        {if (true) throw new TypeModeError(
                                "Number of arguments in mode declaration is different from "
                                + "type declaration in predicate(s) " + names);}
                }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case REALLY:
      jj_consume_token(REALLY);
                                  toBeCheck = false;
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    jj_consume_token(IS);
    mode = PredMode();
                if (bList.size() == 0) {
                        if (mode.isMulti() || mode.isNondet()) {
                                {if (true) throw new TypeModeError(
                                        "Predicate with no argument can never return more than "
                                        + "one result in the predicate(s)" + names);}
                        }
                }
                predModes.add(Factory.makePredicateMode(bList, mode, toBeCheck));
  }

  final public BindingList ModeElem(BindingList bList) throws ParseException {
        BindingMode bm;
    bm = Mode();
                bList.add(bm);
                {if (true) return bList;}
    throw new Error("Missing return statement in function");
  }

  final public BindingMode Mode() throws ParseException {
        Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      t = jj_consume_token(IDENTIFIER);
                        if (t.image.equals("B"))
                                {if (true) return Factory.makeBound();}
                        else if (t.image.equals("F") || t.image.equals("FREE"))
                                {if (true) return Factory.makeFree();}
                        else
                                {if (true) throw new ParseException("Unknow binding mode " + t.image);}
      break;
    case BOUND:
      jj_consume_token(BOUND);
                          {if (true) return Factory.makeBound();}
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Mode PredMode() throws ParseException {
        Mode m;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DET:
      m = Det();
      break;
    case SEMIDET:
      m = SemiDet();
      break;
    case MULTI:
      m = Multi();
      break;
    case NONDET:
      m = NonDet();
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                                          {if (true) return m;}
    throw new Error("Missing return statement in function");
  }

  final public Mode Det() throws ParseException {
    jj_consume_token(DET);
                          {if (true) return Mode.makeDet();}
    throw new Error("Missing return statement in function");
  }

  final public Mode SemiDet() throws ParseException {
    jj_consume_token(SEMIDET);
                          {if (true) return Mode.makeSemidet();}
    throw new Error("Missing return statement in function");
  }

  final public Mode Multi() throws ParseException {
    jj_consume_token(MULTI);
                          {if (true) return Mode.makeMulti();}
    throw new Error("Missing return statement in function");
  }

  final public Mode NonDet() throws ParseException {
    jj_consume_token(NONDET);
                          {if (true) return Mode.makeNondet();}
    throw new Error("Missing return statement in function");
  }

  final public TypeConstructor ExistingTypeAtomName(QueryEngine rules) throws ParseException, TypeModeError {
        Token t;
    t = jj_consume_token(IDENTIFIER);
                                          {if (true) return rules.findType(t.image);}
    throw new Error("Missing return statement in function");
  }

  final public void UserDefinedTypeDeclaration(QueryEngine rules) throws ParseException, TypeModeError {
        CompositeType t1;
        Type t2, representedBy;
        TVarFactory tfact = new TVarFactory();
    jj_consume_token(TYPEDEF);
    t1 = NewCompositeType(rules, tfact);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRICT:
      jj_consume_token(STRICT);
      t2 = ExistingType(rules, tfact);
                                                                          t1.addSubType(t2);
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VERTSLASH:
          ;
          break;
        default:
          jj_la1[19] = jj_gen;
          break label_4;
        }
        jj_consume_token(VERTSLASH);
        t2 = ExistingType(rules, tfact);
                                                                  t1.addSubType(t2);
      }
      break;
    case REPRESENTED_AS:
      jj_consume_token(REPRESENTED_AS);
      representedBy = Type(tfact, rules);
                        t1.setRepresentationType(representedBy);
                        rules.addFunctorConst(representedBy, t1);
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public CompositeType NewCompositeType(QueryEngine rules, TVarFactory tfact) throws ParseException, TypeModeError {
        Token t;
        Type arg;
        TupleType tuple = Factory.makeTupleType();
    t = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LANGLE:
      tuple = tupleOfTVars(tfact);
      break;
    default:
      jj_la1[21] = jj_gen;
      ;
    }
          {if (true) return rules.addNewType(
                (CompositeType) Factory.makeTypeConstructor(t.image, tuple.size()).apply(tuple, false));}
    throw new Error("Missing return statement in function");
  }

  final public Type ExistingType(QueryEngine rules, TVarFactory tfact) throws ParseException, TypeModeError {
        Token t;
        TupleType tuple = Factory.makeTupleType();
    t = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LANGLE:
      tuple = tupleOfTVars(tfact);
      break;
    default:
      jj_la1[22] = jj_gen;
      ;
    }
          {if (true) return rules.findTypeConst(t.image, tuple.size()).apply(tuple, false);}
    throw new Error("Missing return statement in function");
  }

  final public TupleType tupleOfTVars(TVarFactory tfact) throws ParseException {
        Type arg;
        TupleType tuple = Factory.makeTupleType();
    jj_consume_token(LANGLE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VARIABLE:
      arg = TypeVariable(tfact);
                                     tuple.add(arg);
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[23] = jj_gen;
          break label_5;
        }
        jj_consume_token(COMMA);
        arg = TypeVariable(tfact);
                                          tuple.add(arg);
      }
      break;
    default:
      jj_la1[24] = jj_gen;
      ;
    }
    jj_consume_token(RANGLE);
          {if (true) return tuple;}
    throw new Error("Missing return statement in function");
  }

  final public void Query(QueryEngine rules) throws ParseException, TypeModeError {
        RBExpression q;
        Frame solution;
        ElementSource solutions;
    jj_consume_token(WHEN);
    q = Expression(rules);
    jj_consume_token(DOT);
                System.err.println("##QUERY : " + q);
                solutions = rules.frameQuery(q);
                if (!solutions.hasMoreElements()) {
                        System.err.println();
                        System.err.println("FAILURE");
                }
                else {
                        while (solutions.hasMoreElements()) {
                                System.err.println();
                                solution = (Frame)solutions.nextElement();
                                //q.substitute(solution).print(System.err);
                                //System.err.print('.');
                                System.err.print(solution.toString());
                        }
                        System.err.println();
                }
                System.err.println("##END QUERY");
  }

  final public ModeCase ModeCase(QueryEngine rules) throws ParseException, TypeModeError {
        RBExpression exp;
        Collection boundVars = new HashSet();
        RBVariable var;
    jj_consume_token(BOUND);
    label_6:
    while (true) {
      var = Variable();
                                     boundVars.add(var);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VARIABLE:
        ;
        break;
      default:
        jj_la1[25] = jj_gen;
        break label_6;
      }
    }
    jj_consume_token(74);
    exp = Expression(rules);
                                      {if (true) return new ModeCase(boundVars, exp);}
    throw new Error("Missing return statement in function");
  }

  final public RBExpression ModeSwitchExpression(QueryEngine rules) throws ParseException, TypeModeError {
        RBModeSwitchExpression msExp;
        ModeCase mc;
        RBExpression defaultExp;
    mc = ModeCase(rules);
                                       msExp = new RBModeSwitchExpression(mc);
    label_7:
    while (true) {
      if (jj_2_3(2)) {
        ;
      } else {
        break label_7;
      }
      jj_consume_token(VERTSLASH);
      mc = ModeCase(rules);
                                               msExp.addModeCase(mc);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VERTSLASH:
      jj_consume_token(VERTSLASH);
      jj_consume_token(DEF);
      jj_consume_token(74);
      defaultExp = Expression(rules);
                          msExp.addDefaultCase(defaultExp);
      break;
    default:
      jj_la1[26] = jj_gen;
      ;
    }
            {if (true) return msExp;}
    throw new Error("Missing return statement in function");
  }

  final public RBExpression ExpressionAndEOF(QueryEngine rules) throws ParseException, TypeModeError {
        RBExpression e;
    e = Expression(rules);
    jj_consume_token(0);
         {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public RBExpression Expression(QueryEngine rules) throws ParseException, TypeModeError {
        RBExpression e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXISTS:
    case UNIQUE:
      e = Quantifier(rules);
      break;
    case NOT:
    case FINDALL:
    case COUNTALL:
    case TEST:
    case LPAREN:
    case IDENTIFIER:
      e = Disjunction(rules);
      break;
    default:
      jj_la1[27] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public RBExpression Disjunction(QueryEngine rules) throws ParseException, TypeModeError {
        RBExpression e1, e2;
        RBCompoundExpression ce = null;
    e1 = Conjunction(rules);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMICOLON:
        ;
        break;
      default:
        jj_la1[28] = jj_gen;
        break label_8;
      }
      jj_consume_token(SEMICOLON);
      e2 = Conjunction(rules);
                        if (ce == null)
                                ce = new RBDisjunction(e1, e2);
                        else
                                ce.addSubexp(e2);
    }
          if (ce == null) {if (true) return e1;} else {if (true) return ce;}
    throw new Error("Missing return statement in function");
  }

  final public RBExpression Conjunction(QueryEngine rules) throws ParseException, TypeModeError {
        RBExpression e1, e2;
        RBCompoundExpression ce = null;
    e1 = Predicate(rules);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[29] = jj_gen;
        break label_9;
      }
      jj_consume_token(COMMA);
      e2 = Predicate(rules);
                        if (ce == null)
                                ce = FrontEnd.makeAnd(e1, e2);
                        else {
                                ce.addSubexp(e2);
                        }
    }
          if (ce==null) {if (true) return e1;} else {if (true) return ce;}
    throw new Error("Missing return statement in function");
  }

  final public RBExpression Predicate(QueryEngine rules) throws ParseException, TypeModeError {
        RBExpression e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      e = PredicateExpression(rules);
      break;
    case NOT:
      e = NotFilter(rules);
      break;
    case TEST:
      e = TestFilter(rules);
      break;
    case FINDALL:
      e = FindAll(rules);
      break;
    case COUNTALL:
      e = CountAll(rules);
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      e = Expression(rules);
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public RBExpression PredicateExpression(QueryEngine rules) throws ParseException, TypeModeError {
        Token t;
        ArrayList terms = new ArrayList();
        TypeConstructor type;
        String typeName;
    t = jj_consume_token(IDENTIFIER);
    jj_consume_token(LPAREN);
    TermList(terms, rules);
    jj_consume_token(RPAREN);
                {if (true) return new RBPredicateExpression(t.image, terms);}
    throw new Error("Missing return statement in function");
  }

//RBExpression BoundFilter(QueryEngine rules) :
//{ RBVariable v;}
//{
//  "BOUND" "(" v = Variable() ")"
//  { return new RBBoundFilter(v); }
//}

//RBExpression Assert(QueryEngine rules) throws TypeModeError :
//{ RBTerm fact;}
//{
//  "ASSERT" "(" fact = Term(rules) ")"
//  { return new RBAssert(fact,rules); }
//}

//RBExpression Retract(QueryEngine rules) :
//{ RBTerm fact;}
//{
//  "RETRACT" "(" fact = Term(rules) ")"
//  { return new RBRetract(fact,rules); }
//}
  final public RBExpression FindAll(QueryEngine rules) throws ParseException, TypeModeError {
        RBExpression p;
        RBTerm t1,t2;
    jj_consume_token(FINDALL);
    jj_consume_token(LPAREN);
    p = Predicate(rules);
    jj_consume_token(COMMA);
    t1 = Term(rules);
    jj_consume_token(COMMA);
    t2 = Term(rules);
    jj_consume_token(RPAREN);
          {if (true) return new RBFindAll(p, t1, t2);}
    throw new Error("Missing return statement in function");
  }

  final public RBExpression CountAll(QueryEngine rules) throws ParseException, TypeModeError {
        RBExpression p;
        RBTerm t1,t2;
    jj_consume_token(COUNTALL);
    jj_consume_token(LPAREN);
    p = Predicate(rules);
    jj_consume_token(COMMA);
    t1 = Term(rules);
    jj_consume_token(COMMA);
    t2 = Term(rules);
    jj_consume_token(RPAREN);
          {if (true) return new RBCountAll(p, t1, t2);}
    throw new Error("Missing return statement in function");
  }

//RBExpression Term2List(QueryEngine rules) throws TypeModeError :
//{ 	RBTerm t1,t2; }
//{
//	"TERM2LIST" "(" 
//	t1 = Term(rules) "," 
//	t2 = Term(rules) ")"
//	{ return new RBTerm2List(t1,t2); }
//}

//RBExpression FirstOf(QueryEngine rules) throws TypeModeError :
//{	RBExpression p; }
//{
//	"FIRST" "(" p = Expression(rules) ")"
//	{ return new RBFirstOf(p); }
//}

//RBExpression NoDuplicates(QueryEngine rules) throws TypeModeError :
//{	RBExpression e; RBTerm t; }
//{
//	"NODUP" "(" 
//	t=Term(rules) "," 
//	e = Expression(rules) ")"
//	{ return new RBDuplicatesFilter(t,e); } 
//}

//RBExpression JavaSend(QueryEngine rules) throws TypeModeError :
//{ RBTerm receiver,message,arguments,result=null; }
//{
//  ("JAVASEND" "(" receiver=Term(rules) "," message=Term(rules) "," arguments=Term(rules) ["," result=Term(rules)] ")"
//     { return new RBJavaSend(receiver,message,arguments,result); })
//| ("JAVASOLVE" "(" receiver=Term(rules) "," message=Term(rules) "," arguments=Term(rules) "," result=Term(rules) ")"
//     { return new RBJavaSolve(receiver,message,arguments,result); })
//}
  final public RBExpression NotFilter(QueryEngine rules) throws ParseException, TypeModeError {
        RBExpression e;
    jj_consume_token(NOT);
    jj_consume_token(LPAREN);
    e = Expression(rules);
    jj_consume_token(RPAREN);
          {if (true) return new RBNotFilter(e);}
    throw new Error("Missing return statement in function");
  }

  final public RBExpression TestFilter(QueryEngine rules) throws ParseException, TypeModeError {
        RBExpression e;
    jj_consume_token(TEST);
    jj_consume_token(LPAREN);
    e = Expression(rules);
    jj_consume_token(RPAREN);
          {if (true) return new RBTestFilter(e);}
    throw new Error("Missing return statement in function");
  }

  final public RBExpression Quantifier(QueryEngine rules) throws ParseException, TypeModeError {
        RBExpression e;
        Token t;
        ArrayList vars = new ArrayList();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXISTS:
      t = jj_consume_token(EXISTS);
      break;
    case UNIQUE:
      t = jj_consume_token(UNIQUE);
      break;
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    varList(vars);
    jj_consume_token(74);
    e = Expression(rules);
                if (t.image == "EXISTS")
                        {if (true) return new RBExistsQuantifier(vars, e);}
                else if (t.image == "UNIQUE")
                        {if (true) return new RBUniqueQuantifier(vars, e);}
    throw new Error("Missing return statement in function");
  }

  final public void varList(ArrayList v) throws ParseException {
        RBVariable var;
    var = Variable();
                           v.add(var);
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[32] = jj_gen;
        break label_10;
      }
      jj_consume_token(COMMA);
      var = Variable();
                  v.add(var);
    }
  }

  final public RBTerm Term(QueryEngine rules) throws ParseException, TypeModeError {
        RBTerm t;
    if (jj_2_4(2)) {
      t = CompoundTerm(rules);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case VARIABLE:
      case TEMPLATE_VAR:
      case JAVA_CLASS:
      case REGEXP:
        t = SimpleTerm(rules);
        break;
      case LANGLE:
        t = Tuple(rules);
        break;
      case QUOTEDCODE:
        t = QuotedCode();
        break;
      case LBRACKET:
        t = List(rules);
        break;
      default:
        jj_la1[33] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
          {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public RBTerm Tuple(QueryEngine rules) throws ParseException, TypeModeError {
        ArrayList terms = new ArrayList();
    jj_consume_token(LANGLE);
    TermList(terms, rules);
    jj_consume_token(RANGLE);
          {if (true) return RBTuple.make(terms);}
    throw new Error("Missing return statement in function");
  }

  final public RBTerm CompoundTerm(QueryEngine rules) throws ParseException, TypeModeError {
        RBTerm t;
        Token typeName;
        ArrayList terms = new ArrayList();
    if (jj_2_5(2)) {
      typeName = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LANGLE:
        jj_consume_token(LANGLE);
        TermList(terms, rules);
                          t = rules.findConstructorType(new FunctorIdentifier(typeName.image, terms.size()))
                                .apply(terms);
        jj_consume_token(RANGLE);
        break;
      case LBRACKET:
        jj_consume_token(LBRACKET);
        t = RealTermList(rules);
                          t = rules.findConstructorType(new FunctorIdentifier(typeName.image, 1))
                                .apply(t);
        jj_consume_token(RBRACKET);
        break;
      default:
        jj_la1[34] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } else if (jj_2_6(2)) {
      t = SimpleTerm(rules);
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
          {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public RBTerm SimpleTerm(QueryEngine rules) throws ParseException, TypeModeError {
        RBTerm t;
        TypeConstructor typeAtom;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case TEMPLATE_VAR:
    case JAVA_CLASS:
    case REGEXP:
      t = Constant();
      break;
    case VARIABLE:
      t = Variable();
      break;
    default:
      jj_la1[35] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TYPE:
      jj_consume_token(TYPE);
      typeAtom = ExistingTypeAtomName(rules);
                                                    t = t.addTypeCast(typeAtom);
      break;
    default:
      jj_la1[36] = jj_gen;
      ;
    }
          {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public RBTerm List(QueryEngine rules) throws ParseException, TypeModeError {
        RBTerm r;
    jj_consume_token(LBRACKET);
    r = RealTermList(rules);
    jj_consume_token(RBRACKET);
          {if (true) return r;}
    throw new Error("Missing return statement in function");
  }

  final public RBTerm Constant() throws ParseException {
        Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      t = jj_consume_token(INTEGER_LITERAL);
                                                  {if (true) return FrontEnd.makeInteger(t.image);}
      break;
    case FLOATING_POINT_LITERAL:
      t = jj_consume_token(FLOATING_POINT_LITERAL);
                                          {if (true) return FrontEnd.makeReal(t.image);}
      break;
    case STRING_LITERAL:
      t = jj_consume_token(STRING_LITERAL);
                                                  {if (true) return FrontEnd.makeName(stringLiteral(t.image));}
      break;
    case IDENTIFIER:
      t = jj_consume_token(IDENTIFIER);
                                                  {if (true) return FrontEnd.makeName(t.image);}
      break;
    case TEMPLATE_VAR:
      t = jj_consume_token(TEMPLATE_VAR);
                                                  {if (true) return FrontEnd.makeTemplateVar(t.image);}
      break;
    case JAVA_CLASS:
      t = jj_consume_token(JAVA_CLASS);
                                                  {if (true) return RBJavaObjectCompoundTerm.javaClass(javaClassName(t.image));}
      break;
    case REGEXP:
      t = jj_consume_token(REGEXP);
                                                          {if (true) return RBJavaObjectCompoundTerm.regexp(stripQuotes(t.image));}
      break;
    default:
      jj_la1[37] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void TermList(ArrayList terms, QueryEngine rules) throws ParseException, TypeModeError {
        RBTerm t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case LBRACKET:
    case LANGLE:
    case IDENTIFIER:
    case VARIABLE:
    case TEMPLATE_VAR:
    case JAVA_CLASS:
    case REGEXP:
    case QUOTEDCODE:
      t = Term(rules);
                                  terms.add(t);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        TermList(terms, rules);
        break;
      default:
        jj_la1[38] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[39] = jj_gen;
      ;
    }
  }

  final public RBTerm RealTermList(QueryEngine rules) throws ParseException, TypeModeError {
        RBTerm t1, t2 = FrontEnd.theEmptyList;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case LBRACKET:
    case LANGLE:
    case IDENTIFIER:
    case VARIABLE:
    case TEMPLATE_VAR:
    case JAVA_CLASS:
    case REGEXP:
    case QUOTEDCODE:
      t1 = Term(rules);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
      case VERTSLASH:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          jj_consume_token(COMMA);
          t2 = RealTermList(rules);
          break;
        case VERTSLASH:
          jj_consume_token(VERTSLASH);
          t2 = Term(rules);
          break;
        default:
          jj_la1[40] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[41] = jj_gen;
        ;
      }
                  {if (true) return new RBPair(t1, t2);}
      break;
    default:
      jj_la1[42] = jj_gen;
                          {if (true) return FrontEnd.theEmptyList;}
    }
    throw new Error("Missing return statement in function");
  }

  final public RBVariable Variable() throws ParseException {
        Token t;
        RBVariable var;
    t = jj_consume_token(VARIABLE);
                if (t.image.length() == 1)
                        var = FrontEnd.makeIgnoredVar();
                else
                        var = FrontEnd.makeVar(t.image);
          {if (true) return var;}
    throw new Error("Missing return statement in function");
  }

  final public RBTerm QuotedCode() throws ParseException {
        Token t;
    t = jj_consume_token(QUOTEDCODE);
          {if (true) return makeQuotedCode(t.image);}
    throw new Error("Missing return statement in function");
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  final private boolean jj_3R_11() {
    if (jj_3R_18()) return true;
    if (jj_scan_token(TYPE)) return true;
    return false;
  }

  final private boolean jj_3R_42() {
    if (jj_scan_token(VARIABLE)) return true;
    return false;
  }

  final private boolean jj_3R_25() {
    if (jj_3R_28()) return true;
    return false;
  }

  final private boolean jj_3R_24() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  final private boolean jj_3R_20() {
    if (jj_scan_token(LANGLE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_25()) jj_scanpos = xsp;
    if (jj_scan_token(RANGLE)) return true;
    return false;
  }

  final private boolean jj_3R_22() {
    if (jj_3R_27()) return true;
    return false;
  }

  final private boolean jj_3R_35() {
    if (jj_scan_token(REGEXP)) return true;
    return false;
  }

  final private boolean jj_3R_13() {
    if (jj_scan_token(BOUND)) return true;
    return false;
  }

  final private boolean jj_3R_34() {
    if (jj_scan_token(JAVA_CLASS)) return true;
    return false;
  }

  final private boolean jj_3R_18() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_24()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_26() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_29()) {
    jj_scanpos = xsp;
    if (jj_3R_30()) {
    jj_scanpos = xsp;
    if (jj_3R_31()) {
    jj_scanpos = xsp;
    if (jj_3R_32()) {
    jj_scanpos = xsp;
    if (jj_3R_33()) {
    jj_scanpos = xsp;
    if (jj_3R_34()) {
    jj_scanpos = xsp;
    if (jj_3R_35()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_29() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_33() {
    if (jj_scan_token(TEMPLATE_VAR)) return true;
    return false;
  }

  final private boolean jj_3R_32() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_31() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_30() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_43() {
    if (jj_scan_token(LBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_21() {
    if (jj_3R_26()) return true;
    return false;
  }

  final private boolean jj_3R_17() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_21()) {
    jj_scanpos = xsp;
    if (jj_3R_22()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_23()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3_6() {
    if (jj_3R_17()) return true;
    return false;
  }

  final private boolean jj_3R_23() {
    if (jj_scan_token(TYPE)) return true;
    return false;
  }

  final private boolean jj_3R_19() {
    if (jj_scan_token(STRICT)) return true;
    return false;
  }

  final private boolean jj_3R_12() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_19()) jj_scanpos = xsp;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_3R_20()) return true;
    return false;
  }

  final private boolean jj_3R_16() {
    if (jj_scan_token(LBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_15() {
    if (jj_scan_token(LANGLE)) return true;
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_15()) {
    jj_scanpos = xsp;
    if (jj_3R_16()) return true;
    }
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_3R_11()) return true;
    return false;
  }

  final private boolean jj_3R_44() {
    if (jj_scan_token(STRICT)) return true;
    return false;
  }

  final private boolean jj_3R_41() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_44()) jj_scanpos = xsp;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_14() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_5()) {
    jj_scanpos = xsp;
    if (jj_3_6()) return true;
    }
    return false;
  }

  final private boolean jj_3R_40() {
    if (jj_3R_43()) return true;
    return false;
  }

  final private boolean jj_3R_39() {
    if (jj_3R_20()) return true;
    return false;
  }

  final private boolean jj_3R_38() {
    if (jj_3R_42()) return true;
    return false;
  }

  final private boolean jj_3R_37() {
    if (jj_3R_41()) return true;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_3R_12()) return true;
    return false;
  }

  final private boolean jj_3R_36() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_2()) {
    jj_scanpos = xsp;
    if (jj_3R_37()) {
    jj_scanpos = xsp;
    if (jj_3R_38()) {
    jj_scanpos = xsp;
    if (jj_3R_39()) {
    jj_scanpos = xsp;
    if (jj_3R_40()) return true;
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_28() {
    if (jj_3R_36()) return true;
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_3R_14()) return true;
    return false;
  }

  final private boolean jj_3R_27() {
    if (jj_scan_token(VARIABLE)) return true;
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_scan_token(VERTSLASH)) return true;
    if (jj_3R_13()) return true;
    return false;
  }

  public TyRuBaParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[43];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x4006000,0x4006000,0x7b0000,0x0,0x0,0x0,0x0,0x0,0x800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000000,0x0,0xe0000000,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x7b0000,0x0,0x0,0x590000,0x220000,0x0,0x1440,0x0,0x1440,0x0,0x1440,0x0,0x1440,0x0,0x0,0x1440,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x10400000,0x10400000,0x10000202,0x400000,0x10000,0x32002a00,0x20,0x200,0x0,0x10000,0x32002800,0x2000000,0x2000000,0x32002800,0x10000,0x10000002,0x0,0x10000002,0x1,0x100000,0x2000000,0x2000,0x2000,0x10000,0x20000000,0x20000000,0x100000,0x10000200,0x8000,0x10000,0x10000200,0x0,0x10000,0xf0002800,0x2800,0xf0000000,0x100,0xd0000000,0x10000,0xf0002800,0x110000,0x110000,0xf0002800,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x201,0x0,0x1,0x0,0x1,0x0,0x201,0x0,0x0,0x201,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[6];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public TyRuBaParser(java.io.InputStream stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new TyRuBaParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 43; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 43; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public TyRuBaParser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new TyRuBaParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 43; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 43; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public TyRuBaParser(TyRuBaParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 43; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(TyRuBaParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 43; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[75];
    for (int i = 0; i < 75; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 43; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 75; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 6; i++) {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
